package javaStudy.day4;
//이 클래스는 객체 지향의 예를 위한 클래스 입니다.
//이름에서도 볼수 있듯이, 동물을 정의하도록 할 예정입니다.
/*
 *클래스에는 속성(객체가 발생했을떄, 그 객체의 상태를 나타냄, 자바에서는 이를 MEMBER FIELD 라고함)
 *생성자 (VM 이 실제 INSTANCE 를 생성할때 호출하는 코드를 말함)
 *메서드 (METHOD, 객체가 어떤 행위를 해야할 내용을 담고 있는 코드블럭)
 *
 *을 정의 할 수 있습니다. 위에 썼듯이 각 하는 역할은 모두 틀리니 잘 기억하세요
 */

/*
 * 추상화(abstraction) : 객체지향에서 발생되는 이론.. 상속 관계의 super 클래스가 정의된 목적이, 그 자신이 instance 화 되어
 * 사용되는게 아니라, 상속이 주 목적일때 그 클래스는 추상클래스로 만드는게 일반적이다.
 * 이렇게 추상클래스로 만들게 되면, 상속등의 모든 것들은 다 되지만, 자신의 instance 는 생성이 불가하다(꼭 기억!!!)
 * 또 이런 추상 메서드는 일반적으로 추상메서드를 보유하게 되는데, 이 추상 메서드는, 메서드의 내용부가 없이, 오직 기능을 상속하는데
 * 목적을 두게 되는 경우가 일반적이다. 이런 메서드를 추상메서드로 선언 하고, 이를 자식들이 반드시 오버라이드 하게끔 강제화 하게 된다.
 * 이런 추상 메서드를 하나 이상 보유한 클래스는 명시적으로 추상클래스로 선언 해야 하며, 안그럼 에러이다.
 * 
 * 또한 이런 추상 클래스를 상속받은 자식 클래스는 반드시 추상 메서드를 오버라이드 해야하고, 그렇지 않은 경우, 자식 클래스또한
 * 추상 클래스로 선언이 되어야 한다.
 * */
public abstract class Animal {
	//멤버 필드정의 합니다.
	 private String aType; // 실제 생성된 동물의 타입을 나타내는 변수 선언.
//	private String color;
//	private int age;
	
	//생성자(constructor) : 생성자는 프로그래머가 new 연산자를 이용해서 클래스의 instance 를 생성할때
	//vm 이 해당 클래스에서 찾는, 실제 instance 를 생성하도록 정의된 일종의 메서드 입니다.
	// 때문에 () 가 있는것이죠. 하지만, 메서드(기능)과는 구분이 되어야 하기 떄문에 아래와 같은 규칙을 갖습니다. (꼭 기억하세요)
	/*
	 *1.생성자는 리턴타입을 가질수 없습니다.
	 *2.생성자명은 반드시 클래스 이름과 같아야 합니다.
	 *3.생성자는 메서드의 일종이므로, 파라미터를 가질수 있습니다.
	 *4.만약 프로그래머가 생성자를 하나도 정의 하지 않으면, 컴파일시에 컴파일러가 무인자(파라미터가 없는) 생성자를
	 *코드에 자동으로 넣어줍니다. 이를 기본 생성자라고 합니다.
	 *5/만약 4번과 반대의 경우, 즉 생성자를 하나 이상 정의시에는 기본 컴파일러는 기본 생상자를 넣어주지 않습니다.
	 *6.잘 이해하면 여러분엑 큰 도움이 되는 내용.
	 *생성자는 위의 기능외에, 특정 클래스가 인스턴스화 되는데의 guide 가 될수 있습니다.
	 *이 말은 정의되지 않은 생성자를 호출할수 없기 때문에, 정의된 생성자를 통해서만 객체를 발생할 수 있다는 의미가 됩니다.
	 *즉, 특정 클래스의 객체를 발생시킬때는 정의된 생성자를 먼저 봐야 한다는 의미가 됩니다. 
	 */
	//컴파일러 넣어주는 생성자를 직접 정의해봅니다.
//	public Animal() {
//		aType = null;
//	}
	/*
	 *메서드 시그니쳐(signature) : 생성자, 메서드에 같은 이름으로 한번이상 정의 하면, 에러임.
	 *하지만, 매번 다른 이름으로 정의하면 코드 낭비가 심함.
	 *이를 위해서 , 메서드(생성자) 시그니처가 이를 해결해줌
	 *일단 시그니처를 구성하는 요소는 다음과 같음
	 *파라미터의 갯수, 타입 , 순서임.
	 *위 시그니처가 하나라도 틀리면 같은 메서드(생성자) 이름 이어도, 다른 메서드로 컴파일러가 인식함.
	 *이렇게 정의된 메서드(생성자)는 호출시에 주어진 파라미터값(시그니처)를 통한 동적으로 선택되어져 호출됨
	 *이를 메서드(생성자) 오버로딩(overloading) 이라고 함
	 */
	// 생성자 오버로딩
	public Animal(String aType) {
		this.aType = aType;
		
	}
	//이 메서드는 기능만 가진 추상메서드로 변경합니다.즉 상속만을 목적으로 합니다.
	//꼭 기억!! 이 클래스의 자식은 반드시 오버라이드 해야함.. 안그럼 자신이 추상화 되어야함.
	public abstract void sound();
		
	
	
	//어떤 타입인지 toString()정의함
	public String toString() {
		return "이것은 " + aType;
	}
	//생성자에서의 this([params]);
	/*
	 *생성자에서 this() 를 사용할수 있다. 기존에 정의된 생성자를 호출할떄 사용하는데,
	 *이떄 중요한건 호출 위치이다. 반드시 코드 첫머리에만 허용된다.
	 */
//	public Animal(String aType,String color) {
//		this(aType);
//		this.color = color;
//	}
//	
//	public Animal(String aType,String color, int age) {
//		this(aType,color);
//		this.age = age;
//	}
	
	
	//멤버메스드를 정의 합니다.
	//이 메서드는  이 클래스를 바탕으로 생성된 모든 인스턴스 가지게 됩니다. 떄문에 멘버 메서드 라고 합니다.
	//이 메서드를 정의할 떈 다음과 같은 문법을 따릅니다. 꼮 기억하세요.
	//[접근제어자 public > procteced > default(아무것도 쓰지않음)> private] returnType(p or r or void)
	//methodName (반드시 소문자로 시작하고, 연결되는 다음 단어의 첫문자만 대문자)[type methodParameter(s)...]
	//만약 리턴타입이 void 가 아니면 반드시 메서드는 해당 타입의 값을 리턴(return) 해줘야 합니다.
//	public String displayType() {
//		String aType = "이건지역변수값";
//		// aType을 리턴시킵니다.. 타입 변수엔 값이 들어가 있기 때문입니다.
//		return "이것은" +  this.aType;
//	}
}
